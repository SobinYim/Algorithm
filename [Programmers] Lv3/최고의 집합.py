def solution(n, s): #자연수 n개로 이루어지고 합이 s인 중복 집합
    return [-1] if n>s else [s//n]*(n-s%n)+[s//n+1]*(s%n)

'''
[효율성 테스트] 평균 실행 시간 : 0.07 평균 메모리 사용량: 10.48

중복 집합이라 아주 간단한 문제..
조건 하에서 곱을 최대화하기 위해서는 각 인수를 평균에 가깝게 해야 한다
그러니까 s를 n으로 나눈 몫을 n-s%n 개, 몫에 1을 더한 값을 나머지만큼 반환하면 된다
더 쉽게는 몫을 n개 만큼 만든 후 나머지만큼 뒤에서 1씩 더해도 된다
음 다른 사람들의 풀이에서는 append를 많이 쓰던데 나는 그냥 곱하는 게 더 좋은 것 같다,,
'''