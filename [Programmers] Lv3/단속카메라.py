#sol
def solution(routes): #고속도로를 이동하는 차량의 경로
    routes.sort()
    ans = 0 #설치해야 하는 카메라 대수
    mx = routes[0][1] #카메라를 설치할 수 있는 구간의 최댓값
    for i, j in routes:
        if mx > j: #구간의 최댓값이 차량이 지나가는 구간보다 클 경우 구간을 좁힘
            mx = j
        if i > mx: #해당 구간이 카메라를 설치할 수 있는 구간 바깥일 경우
            ans += 1
            mx = j
    return ans + 1

#sol1 [다른 사람의 풀이 참고]
def solution(routes): #고속도로를 이동하는 차량의 경로
    routes.sort(key=lambda x: x[0])
    ans = 0 #설치해야 하는 카메라 대수
    mx = routes[0][1] #카메라를 설치할 수 있는 구간의 최댓값
    for i, j in routes:
        if mx > j: #구간의 최댓값이 차량이 지나가는 구간보다 클 경우 구간을 좁힘
            mx = j
        if i > mx: #해당 구간이 카메라를 설치할 수 있는 구간 바깥일 경우
            ans += 1
            mx = j
    return ans + 1


'''
sol
[효율성 테스트] 평균 실행 시간 : 0.89 평균 메모리 사용량: 10.38
sol1
[효율성 테스트] 평균 실행 시간 : 0.5 평균 메모리 사용량: 10.28

sol과 sol1은 같은 풀이
정렬 key로 한쪽만 사용하느냐 양쪽을 모두 이용하느냐의 차이이다
결과는 동일하게 나오나 sol1이 정렬 key로 하나만 사용하기 때문에 더 빨랐다
사실 풀 때는 생각 못 하고 다른 사람의 풀이 확인하고 나서야 이런 방법이 있구나 싶었다

정렬 key로 x[0]를 쓰든 x[1]를 쓰든 결과 차이는 없다
마찬가지로 reverse를 이용하여 큰 값부터 순회하든 작은 값부터 순회하든 조건만 수정하면 결과 차이는 없다

풀이 로직은 간단하게 정렬 후, 최댓값을 저장하여 설치할 수 있는 범위, 즉 공통 구간을 만들어주고
이를 벗어나면 ans에 1을 더해 주었다 

다른 사람의 풀이 중 힙을 사용한 풀이도 있었는데
빈 리스트에서 heappush를 이용하여서만 push 했을 경우 heapify를 할 필요가 없다!
사실 당연한 건데 그동안 생각해 본 적이 없었다
'''