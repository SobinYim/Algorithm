#sol1
def solution(n, left, right): #2차원 배열의 크기, 시작점, 끝점
    return [max(i%n,i//n)+1 for i in range(left,right+1)]

#sol2
def solution(n, left, right): #2차원 배열의 크기, 시작점, 끝점
    ans=[]
    for i in range(left//n+1,right//n+2):
        ans+=[i]*i
        ans+=list(range(i+1,n+1))
    k=left%n
    return ans[k:right-left+k+1]

'''
#sol1
평균 실행 시간 : 26.49 평균 메모리 사용량: 17.53
#sol2
평균 실행 시간 : 108.73 평균 메모리 사용량: 108.59

어떤 행의 값은 예를 들어 3번째 행이면 33345...n과 같다
sol1에서는 이를 max를 이용해 비교해서 나온 값을 리스트로 만든다면
sol2는 해당 범위가 속한 행을 리스트로 만든 후 슬라이싱하여 반환한다 
sol2는 사용하지 않는 부분까지 만드는 데다 append가 아니라 리스트끼리 +연산을 해서 메모리 낭비가 좀 심했다,,
특히 list의 크기가 커질수록 이런 문제가 좀 심해지는데 좀 재밌는 건 일부 테스트 케이스에서는 sol2가 빠르게 나왔다
테스트 케이스 6~14가 sol1에서는 약 30ms 정도가 걸린다면 sol2에서는 5ms 정도
아마도 n의 크기는 크고 구해야 하는 (right-left)//n 값은 작은 케이스가 아니었을까 싶다
근데 전체적으로 크기가 커지면 효율성이 너무 떨어져서 좋은 코드라고는 말 못 하겠다....

[q+1 if (r:=i%n)<(q:=i//n) else r+1 for i in range(left,right+1)]
평균 실행 시간 : 17.91 평균 메모리 사용량: 17.59
다른 사람의 풀이에서 몫과 나머지를 월러스 연산자를 이용해서 다시 구하지 않도록 만들었다(물론 드라마틱한 차이는 아니다)
그래도 역시 if로 넣는 게 max를 사용하는 것보다 효율이 좋았다!
'''