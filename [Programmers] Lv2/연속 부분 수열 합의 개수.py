def solution(elements): #원형 수열
    tot=sum(elements)
    l=len(elements)
    elements+=elements #연속성을 위해 수열을 이어줌
    n=[] #부분 수열의 합 리스트
    for i in range(l):
        cnt=0 #부분 수열 횟수
        k=0 #부분 수열의 합
        while cnt<l//2:
            k+=elements[i+cnt] #i+cnt로 elements의 다음 인덱스 덧셈
            n+=[k,tot-k]
            cnt+=1
    return len(set(n))+1 #집합으로 중복 제거 후 전체 수열의 합 +1
'''
평균 실행 시간 : 104.28 평균 메모리 사용량: 43.89

부분 수열의 합은 그러니까,,
예를 들어 원형 수열의 길이가 5라면
길이 1인 부분 수열의 합=전체 수열의 합-길이 4인 부분 수열의 합
길이 2인 부분 수열의 합=전체 수열의 합-길이 3인 부분 수열의 합이다
그러니까 전체 부분 수열을 다 구해줄 필요 없이 l//2 길이의 부분 수열의 합까지만 구해주면 된다는 의미
위 코드는 idx 0부터 길이가 1~(l//2)인 부분 수열의 합 구하고 이를 tot에서 뺀 값과 함께 넣어주고 다음 idx 시작점으로 넘어가고를 반복한다

수열의 길이가 짝수여도 상관이 없는 게 어차피 set로 중복을 제거해 주니까,,
애초에 set를 안 쓰고 리스트 선언 후에 set 변환해 주는 건 
이상하게 경험적으로 add나 update를 이용해 set를 업데이트하는 것보다 오히려 나중에 set 변환하는 편이 빨랐기 때문이다,,,
물론 메모리 부분에서는 set를 사용하는 편이 유리하다
(set 사용 시 평균 실행 시간 : 122.56 평균 메모리 사용량: 30.24)

보통 elements를 이은 후에 for문을 이용하여 슬라이싱하고 이를 합산하여 집합에 추가하는 방법을 많이 썼는데
sum이 생각보다 시간을 필요로 하는 친구라서,, 테스트 케이스 10에서 4000ms를 가볍게 돌파해버린다
모든 길이의 부분 수열을 다 구하더라도 위와 같이 한 인덱스에서 시작하여 차례로 더해가면 불필요한 연산을 줄여 시간을 훨씬 단축할 수 있다
'''