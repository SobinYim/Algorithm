from math import log2
def solution(n,a,b): #참가 인원, 참가자 a,b
    n=int(log2(n)) #라운드
    a,b=bin(a-1)[2:],bin(b-1)[2:] #이진수 변환 (0부터 시작하도록 -1)
    a,b=("0"*n+a)[-n:],("0"*n+b)[-n:] #길이 맞춰주기
    for idx,item in enumerate(zip(a,b)):
        if item[0]!=item[1]:
            return n-idx #a와 b의 비트가 달라지는 부분을 n에서 뺀 값

'''
평균 실행 시간 : 0.01 평균 메모리 사용량: 10.22

비트로 구할 수 있다... 까지는 알았지만...
비트 연산에는 익숙하지 않았던....
a-1, b-1 해주는 이유...
예를 들어 n=16이라면 0~7이 0000~0111, 8~15가 1000~1111 그렇다... 규칙이 있다...
오른쪽부터 x번째 비트가 같다면 x번째 라운드에서 같은 조에 묶인다...

아래는 다른 사람의 풀이에서 본 풀이인데.... 결국에 같은 얘기다...
a-1, b-1 비트에서 달라지는 부분==1 이니까... xor 결과의 length를 구하면... 답이다... 
나는... 라운드에서 달라지는 인덱스를 찾아 빼줬고... 왜... 비트가 달라지는 부분을 구하면서도 이상한 점을 느끼지 못했을까..
def solution(n,a,b):
    return ((a-1)^(b-1)).bit_length()
    
흑흑 
'''